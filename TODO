Need a "write entry name;" feature.

Conditional action blocks need to be explicitly ordered in the same way that
actions are ordered.

Possibly bring back the old semantics of > in a new operator, or allow it to be
defined somehow.

When priorities are embedded without a name, the name of the current machine is
used. Perhaps a unique name for each instance of the current machine should be
used instead. This idea could work well if applied to user-defined embeddings. 

User defined embeddings <-name(a1,a2,...).
User defined operators expr1 <name> expr2.

Doesn't make make sense for [] to be the lambda (zero-length) machine. This
should be the empty set (the empty machine). But then would it be invalid in a
regular expression?

Expressions of the form: expr1 <: expr2 . expr3
sometimes don't behave as expected. If expr2 contains the empty string then
it's possible for the machine to escape to expr3. This is somewhat unexpected.
The empty string does count as moving through the right machine so there should
not be an exception for this case.
Using the stronger implementation: ( expr1 $1 %0 . expr2 ) will solve the problem.

Also, there is potential for nondeterminism to persist via the empty string
with the :> and :>> operators. Should also guard against this using leaving
priorities.

The |> guarded operator and the <| guarded operator need to be added.

The fixed size stack is a problem for manual recursion of unlimited depth.

An option to turn off the removal of duplicate actions might be useful for
analyzing unintentional nondeterminism.

Might be a good idea to add in some protection against using up all of a
system's memory. This protection could then be removed by people when someone
is sure they want to use a lot of memory.

fbreak should advance the current char. Depreciate fbreak and add
    fctl_break;
    fctl_return <expr>;
    fctl_goto <label>;

Should the fbreak functions execute the to-state actions of the target state?

It should be possible to import/export definitions.

If a scanner can be optimized into a pure state machine, maybe permit it to be
referenced as a machine definition. Alternately: inline scanners with an
explicit exit pattern.

The split codegen needs a profiler connected to a graph partitioning algorithm.

Die a graceful death when rlcodegen -F receives large alphabets.

It's not currently possible to have more than one machine in a single function
because of label conflicts. Labels should have a unique prefix.

Emit a warning when a subtraction has no effect.

Emit a warning when unnamed priorities are used in longest match machines.
These priorities may unexpectedly interact across longest-match items. Changing
the language such that unwated interaction cannot happen would require naming
longest-match items.

Testing facilities: Quick easy way to query which strings are accepted.
Enumerate all accepted strings. From Nicholas Maxwell Lester.

Add more examples, add more tests and write more documentation.

A debugger would be nice. Ragel could emit a special debug version that
prompted for debug commands that allowed the user to step through the machine
and get details about where they are in their RL.

A quick and easy alternative would be a trace code generation option. This
would open a trace file and list all the active machines at each step of the
input.

Frontend should allow the redefinition of fsm section delimiters.

Do more to obscure ragel's private variables. Just a leading underscore is not
enough. Maybe something more like __ri__.

Some talk about capturing data:

Separate tokstart/tokend from the backtracking.  One var for preservation,
called preserve.  Write delcarations;  produces the necessary variables used by
ragel.  Move pattern start pattern end concepts into the general?  The
variables which may need to influence the preserve is dependent on the state.
States have a concept of which variables are in use.  Can be used for length
restrictions.  If there is an exit pattern, it is the explicit way out,
otherwise the start state and all final states are a way out.
